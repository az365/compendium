# Algorithms and data structures
### сортировки
- критерии выбора
    - только несколько элементов - insertion sort
    - элементы уже почти отсортированы - insertion sort
    - важна производительность в наихудшем случае - heap sort
    - важна производительность в среднем случае - quicksort
    - элементы с равномерным распределением - bucket sort
    - как можно меньший код - insertion sort
    - требуется устойчивость сортировки - сортировка слиянием
- сортировки перестановками
    - самые ранние алгоритмы
    - разновидности
        - сортировка выбором
        - bubble sort - пузырьковая сортировка
            - O(n2) | O(n2) | O(n2)
            - лежит в основе более совершенных алгоритмов
                - cocktail sort
                - heap sort
                - quicksort
            - сравнивает соседние пары элементов и меняет их местами
- insertion sort - сортировка вставками
    - O(n) | O(n2) | O(n2)
    - когда использовать
        - мало элементов
        - уже почти отсортированы
    - многократно использует insert чтобы отсортировать A[0,i]
- selection sort - сортировка выбором
    - O(n2) | O(n2) | O(n2)
    - самый медленный алгоритм
    - рассматривается как подводящий к heap sort'у
    - пример жадной стратегии
    - переставляет вправо наибольший элемент 
- heap sort - пирамидальная (куча)
    - O(n log n) | O(n log n) | O(n log n)
    - лучшая производительность в наихудшем случае
    - когда использжовать
        - важна производительность в наихудшем случае
    - состоит из build_heap(A) и heapify(A, idx, max)
- quicksort - быстрая сортировка
    - O(n2) | O(n log n) | O(n log n)
    - лучшая производительность в среднем случае
    - состоит из select_pivot_index, do_qsort, sort_pointers
- bucket sort - блочная сортировка
    - O(n) | O(n) | O(n) на удачных данных
    - относится к классу сортировок без сравнений
    - когда использовать
        - при равномерном распределении
    - нужна хеширующая функция, делящая на сортированные бакеты
    - делит элементы на бакеты, сортирует внутри них этим или другим алгоритмом
    - сильно деградирует при большом количестве мало отличных элементов
- merge sort - сортировка слиянием
    - O(n log n) | O(n log n) | O(n log n) при памяти O(n)
    - относится к классу сортировок с использованием дополнительной памяти
    - множество делится на 2, каждое из них сортируется (рекурсивно)
### поиск
- sequential search - последовательный 
    - O(1) | O(n) | O(n)
    - для любого итерабельного объекта
- бинарный 
    - O(1) | O(log n) | O(log n)
    - для отсортированных коллекций
- hash based - на основе хеша 
    - O(1) | O(1) | O(n)
    - требует предварительной обработки O(n)
- bloom - фильтр блума
    - O(k) | O(k) | O(k)
- бинарное дерево поиска
    - O(log n) | O(log n) | O(log n)
    - вариации
        - AVL-tree
        - красно-чёрное дерево
            - ни одна ветвь не может иметь высоту вдвое превосходящую любую другую ветвь
            - это ускоряет вставку/удаление путём сокращения поворотов
